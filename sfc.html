<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>SNES by keita</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
  :root {
        color-scheme: light dark;
      }
      body {
        background:rgb(0, 0, 0);
        font-family: ui-sans-serif, system-ui;
        margin: 16px;
      }
      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
      }
      canvas{
        
        height: 100%;              /* コンテナ幅に合わせる */
      aspect-ratio: 256 / 240;  /* 内部解像度の比率を維持 */
        image-rendering: pixelated;
        border: 1px solid #000000;
        background: #000;
      }
      .row div{
        display:none;
      }
      .row {
        padding-top:0px;
height:83vh;
justify-content: center; 
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
      small {
        opacity: 0.7;
      }
      #romSelect{
display:none;
}
button{
padding:10px;
background:rgb(0, 0, 0);
color:rgb(255, 255, 255);
border:1px solid rgb(255, 255, 255);
}
    </style>
  </head>
  <body>
    <header>
      <input id="rom" type="file" accept=".sfc" />
      <button id="fullscreenBtn">Fullscreen</button>

      <button id="start" disabled>Start</button>
      <div class="mono" id="status">No ROM</div>
      <div class="mono" id="addr">0x0000</div>
      <input type="text" id="myInput" value="30" style="display:none"/>
    </header>
    <div class="row">
      <canvas id="screen" width="256" height="240"></canvas>
      <div>
        <div><b>FPS:</b> <span id="fps">0</span></div>
        <div><b>CPU PC:</b> <span id="pc" class="mono">0x0000</span></div>
        <div><b>Cycles:</b> <span id="cyc" class="mono">0</span></div>
        <div><b>VRAM V:</b><span id="pcp" class="mono">0x0000</span></div>
        <div><b>VRAM T:</b><span id="ppx" class="mono">0x0000</span></div>
        <div><b>CPU S:</b><span id="ram" class="mono">0x0000</span></div>
        <div><b>CPU P:</b><span id="mapper" class="mono">0x0000</span></div>
        <div><b>APU M:</b><span id="apu" class="mono">0x0000</span></div>
        <small
          >Skeleton: Mapper0, iNES, PPU frame timing + NMI, CPU bus/IRQs, opcode
          hooks</small
        >
      </div>
    </div>

    

    <script type="module">
      class PPU {
        constructor(ctx) {
          // ADD
this.bgMode = 0;
this.bg1TileBase = 0x0000;
this.bg1MapBase  = 0x0000;
// constructor
this.vblank = false;

          this.ctx = ctx;
          this.width = 256;
          this.height = 224;
          this.vram = new Uint8Array(64 * 1024); // 64KB
          this.cgram = new Uint8Array(512); // 512B
          this.oam = new Uint8Array(544); // 544B
          this.inidisp = 0x80; // 画面OFF
          this.bgmode = 0; // モード0
          // --- フレームバッファ ---
          // モード0
          this.vramAddr = 0;
          this.cgramAddr = 0;
          this.oamAddr = 0;
          this.bg1ScrollX = 0;
          this.mainScreen = 0;
this.subScreen = 0;

          this.bg1ScrollY = 0;
          this.buffer = new Uint32Array(this.width * this.height);
          this.imageData = ctx.createImageData(this.width, this.height);
        }
        reset() {
          // メモリクリア
          this.vram.fill(0);
          this.cgram.fill(0);
          this.oam.fill(0);
this.cgram = new Uint16Array(256);
this.cgramLatch = 0;
this.cgramLow = true;

          // レジスタ初期化
          this.inidisp = 0x80; // 画面OFF
          this.bgmode = 0;
          this.vramAddr = 0;
          this.cgramAddr = 0;
          this.oamAddr = 0;
         
          // 背景を黒で塗る
          this.buffer.fill(0xff000000);
          this.flush();
        }
        writeVRAM(addr, value) {
          this.vram[addr & 0xffff] = value;
        }

        readVRAM(addr) {
          return this.vram[addr & 0xffff];
        }

        // CGRAM書き込み（パレット）
       writeCGRAM(addr, value) {
  if (this.cgramLow) {
    this.cgramLatch = value;
    this.cgramLow = false;
  } else {
    this.cgram[addr >> 1] = this.cgramLatch | (value << 8);
    this.cgramLow = true;
  }
}

startVBlank() {
  this.vblank = true;
}

        readCGRAM(addr) {
          return this.cgram[addr & 0x1ff];
        }

        // OAM書き込み（スプライト属性）
        writeOAM(addr, value) {
          this.oam[addr % 544] = value;
        }

        readOAM(addr) {
          return this.oam[addr % 544];
        }
        getColor(index) {
  const color = this.cgram[index] & 0x7fff;
  const r = (color & 0x1f) << 3;
  const g = ((color >> 5) & 0x1f) << 3;
  const b = ((color >> 10) & 0x1f) << 3;
  return (255 << 24) | (b << 16) | (g << 8) | r;
}

// ADD
renderSprites() {
  for (let i = 0; i < 128; i++) {
    const o = i * 4;
    const y = this.oam[o];
    const tile = this.oam[o + 1];
    const attr = this.oam[o + 2];
    const x = this.oam[o + 3];
    const pal = attr & 0x7;
    this.drawTile(tile, pal, x, y);
  }
}

        // --- タイル1枚を描画 ---
        drawTile(tileIndex, paletteIndex, dx, dy) {
          const base = tileIndex * 32; // 1タイル=32バイト
          for (let row = 0; row < 8; row++) {
            // 4bpp: 2bitplane×2
            const p0 = this.vram[base + row * 2];
            const p1 = this.vram[base + row * 2 + 1];
            const p2 = this.vram[base + 16 + row * 2];
            const p3 = this.vram[base + 16 + row * 2 + 1];
            for (let col = 0; col < 8; col++) {
              const bit = 7 - col;
              const colorIndex =
                ((p0 >> bit) & 1) |
                (((p1 >> bit) & 1) << 1) |
                (((p2 >> bit) & 1) << 2) |
                (((p3 >> bit) & 1) << 3);
              if (colorIndex === 0) continue; // 透明色
              const paletteColor = this.getColor(
                paletteIndex * 16 + colorIndex
              );
              this.buffer[(dy + row) * this.width + (dx + col)] = paletteColor;
            }
          }
        }
drawTile2bpp(addr, pal, dx, dy) {
  for (let y = 0; y < 8; y++) {
    const p0 = this.vram[addr + y * 2];
    const p1 = this.vram[addr + y * 2 + 1];

    for (let x = 0; x < 8; x++) {
      const bit = 7 - x;
      const c = ((p0 >> bit) & 1) | (((p1 >> bit) & 1) << 1);
      if (c === 0) continue;
      this.buffer[(dy + y) * this.width + (dx + x)] =
        this.getColor(pal * 4 + c);
    }
  }
}

        // --- 背景マップを描画 ---
     renderBG1() {
  // 画面OFFなら描かない
  if (this.inidisp & 0x80) return;

  // BG1 無効
  if ((this.mainScreen & 0x01) === 0) return;

  // モード0のみ
  if (this.bgMode !== 0) return;

  for (let ty = 0; ty < 28; ty++) {
    for (let tx = 0; tx < 32; tx++) {
      const mapAddr = this.bg1MapBase + (ty * 32 + tx) * 2;
      const lo = this.vram[mapAddr];
      const hi = this.vram[mapAddr + 1];

      const tile = lo | ((hi & 0x03) << 8);
      const pal  = (hi >> 2) & 0x07;

      const tileAddr = this.bg1TileBase + tile * 16; // 2bpp
      this.drawTile2bpp(tileAddr, pal, tx * 8, ty * 8);
    }
  }
}



drawTileAt(addr, pal, dx, dy) {
  for (let y = 0; y < 8; y++) {
    const p0 = this.vram[addr + y * 2];
    const p1 = this.vram[addr + y * 2 + 1];
    const p2 = this.vram[addr + 16 + y * 2];
    const p3 = this.vram[addr + 16 + y * 2 + 1];

    for (let x = 0; x < 8; x++) {
      const bit = 7 - x;
      const c =
        ((p0 >> bit) & 1) |
        (((p1 >> bit) & 1) << 1) |
        (((p2 >> bit) & 1) << 2) |
        (((p3 >> bit) & 1) << 3);

      if (c === 0) continue;
      this.buffer[(dy + y) * this.width + (dx + x)] =
        this.getColor(pal * 16 + c);
    }
  }
}

        // テスト用: グラデーション描画
        setScrollX(val) {
          this.bg1ScrollX = val;
        }
        setScrollY(val) {
          this.bg1ScrollY = val;
        }
// ADD in PPU
startVBlank(bus) {
  bus.nmiFlag = true;
}

       
        renderBGColor() {
  // 画面OFFならバックドロップのみ
  if (this.inidisp & 0x80) {
    this.buffer.fill(0xff000000); // 黒
    return;
  }

  const col = this.getColor(0);
  this.buffer.fill(col);
}

        flush() {
  const data = this.imageData.data;
  for (let i = 0; i < this.buffer.length; i++) {
    const c = this.buffer[i];
    data[i * 4 + 0] = c & 0xff;         // R
    data[i * 4 + 1] = (c >> 8) & 0xff;  // G
    data[i * 4 + 2] = (c >> 16) & 0xff; // B
    data[i * 4 + 3] = (c >> 24) & 0xff; // A
  }
  this.ctx.putImageData(this.imageData, 0, 0);
}

      }

      const FLAG = {
        C: 1 << 0,
        Z: 1 << 1,
        I: 1 << 2,
        D: 1 << 3,
        X: 1 << 4,
        M: 1 << 5,
        V: 1 << 6,
        N: 1 << 7,
      };
      class CPU65C816 {
        constructor() {
          this.PC = 0x8000;
          this.A = 0;
          this.X = 0;
          this.Y = 0;
          this.S = 0x1ff;
          this.D = 0;
          this.DB = 0;
          this.PB = 0;
          this.P = 0x34;
          this.emulation = true;
          this.cycles = 0;
        }
        reset(bus) {
  // SNES RESET vector ($00:FFFC)
  const lo = bus.read(0x00fffc);
  const hi = bus.read(0x00fffd);

  this.PC = lo | (hi << 8);
this.op;
  // 初期CPU状態（最低限）
  this.SP = 0x1ff;
  this.P  = 0x34;   // IRQ禁止・8bitモード
  this.A = this.X = this.Y = 0;
}

        // ADD inside CPU class
read16(bus, addr) {
  const lo = bus.read(addr);
  const hi = bus.read((addr + 1) & 0xffff);
  return lo | (hi << 8);
}

imm8(bus) {
  return bus.read((this.PB << 16) | this.PC++);
}

abs(bus) {
  const lo = this.imm8(bus);
  const hi = this.imm8(bus);
  return (this.DB << 16) | (hi << 8) | lo;
}

        setZN(value) {
          if ((value & 0xff) === 0) {
            this.P |= FLAG.Z;
          } else {
            this.P &= ~FLAG.Z;
          }
          if (value & 0x80) {
            this.P |= FLAG.N;
          } else {
            this.P &= ~FLAG.N;
          }
        }
        read8(bus) {
  const val = bus.read((this.PB << 16) | this.PC);
  this.PC = (this.PC + 1) & 0xffff;
  return val;
}

read16(bus) {
  const lo = this.read8(bus);
  const hi = this.read8(bus);
  return lo | (hi << 8);
}

updateWidthFlags() {
  this.mWidth = (this.P & 0x20) === 0 ? 16 : 8;
  this.xWidth = (this.P & 0x10) === 0 ? 16 : 8;
}

        step(bus) {
          const opcode = bus.read((this.PB << 16) | this.PC);
          this.PC = (this.PC + 1) & 0xffff;
// ADD at top of CPU.step()
if (bus.nmiFlag && !(this.P & FLAG.I)) {
  bus.nmiFlag = false;

  bus.write(0x100 | (this.S-- & 0xff), (this.PC >> 8) & 0xff);
  bus.write(0x100 | (this.S-- & 0xff), this.PC & 0xff);
  bus.write(0x100 | (this.S-- & 0xff), this.P);

  const lo = bus.read(0xffea);
  const hi = bus.read(0xffeb);
  this.PC = lo | (hi << 8);
  this.cycles += 7;
  return;
}


this.op=opcode;
          switch (opcode) {
          

            // Load/Store operations
            case 0xa9: // LDA #imm
              this.A = bus.read((this.PB << 16) | this.PC);
              this.PC = (this.PC + 1) & 0xffff;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0xa5: // LDA dp
              const dpA = bus.read((this.PB << 16) | this.PC++);
              this.A = bus.read((this.D + dpA) & 0xffff);
              this.setZN(this.A);
              this.cycles += 3;
              break;

            case 0xad: // LDA abs
              const loA = bus.read((this.PB << 16) | this.PC++);
              const hiA = bus.read((this.PB << 16) | this.PC++);
              this.A = bus.read((hiA << 8) | loA);
              this.setZN(this.A);
              this.cycles += 4;
              break;

            case 0xa2: // LDX #imm
              this.X = bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0xa6: // LDX dp
              const dpX = bus.read((this.PB << 16) | this.PC++);
              this.X = bus.read((this.D + dpX) & 0xffff);
              this.setZN(this.X);
              this.cycles += 3;
              break;

            case 0xae: // LDX abs
              const loLX = bus.read((this.PB << 16) | this.PC++);
              const hiLX = bus.read((this.PB << 16) | this.PC++);
              this.X = bus.read((hiLX << 8) | loLX);
              this.setZN(this.X);
              this.cycles += 4;
              break;

            case 0xa0: // LDY #imm
              this.Y = bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.Y);
              this.cycles += 2;
              break;
// ADD opcode
case 0xbd: { // LDA abs,X
  const base = this.abs(bus);
  this.A = bus.read((base + this.X) & 0xffffff);
  this.setZN(this.A);
  this.cycles += 4;
  break;
}

            case 0xa4: // LDY dp
              const dpY = bus.read((this.PB << 16) | this.PC++);
              this.Y = bus.read((this.D + dpY) & 0xffff);
              this.setZN(this.Y);
              this.cycles += 3;
              break;

            case 0xac: // LDY abs
              const loLY = bus.read((this.PB << 16) | this.PC++);
              const hiLY = bus.read((this.PB << 16) | this.PC++);
              this.Y = bus.read((hiLY << 8) | loLY);
              this.setZN(this.Y);
              this.cycles += 4;
              break;

            case 0x85: // STA dp
              const dpSA = bus.read((this.PB << 16) | this.PC++);
              bus.write((this.D + dpSA) & 0xffff, this.A & 0xff);
              this.cycles += 3;
              break;

            // STA absolute
case 0x8D: { // STA absolute
  const lo = this.read8(bus);
  const hi = this.read8(bus);
  const addr = (this.PB << 16) | (hi << 8) | lo;

  if (this.mWidth === 16) {
    bus.write(addr, this.A & 0xff);
    bus.write(addr + 1, (this.A >> 8) & 0xff);
  } else {
    bus.write(addr, this.A & 0xff);
  }

  this.cycles += 4;
  break;
}



            case 0x86: // STX dp
              const dpSX = bus.read((this.PB << 16) | this.PC++);
              bus.write((this.D + dpSX) & 0xffff, this.X & 0xff);
              this.cycles += 3;
              break;

            case 0x8e: // STX abs
              const loSX = bus.read((this.PB << 16) | this.PC++);
              const hiSX = bus.read((this.PB << 16) | this.PC++);
              bus.write((hiSX << 8) | loSX, this.X & 0xff);
              this.cycles += 4;
              break;

            case 0x84: // STY dp
              const dpSY = bus.read((this.PB << 16) | this.PC++);
              bus.write((this.D + dpSY) & 0xffff, this.Y & 0xff);
              this.cycles += 3;
              break;

            case 0x8c: // STY abs
              const loSY = bus.read((this.PB << 16) | this.PC++);
              const hiSY = bus.read((this.PB << 16) | this.PC++);
              bus.write((hiSY << 8) | loSY, this.Y & 0xff);
              this.cycles += 4;
              break;

            // Increment/Decrement
            case 0xe8: // INX
              this.X = (this.X + 1) & 0xff;
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0xca: // DEX
              this.X = (this.X - 1) & 0xff;
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0xc8: // INY
              this.Y = (this.Y + 1) & 0xff;
              this.setZN(this.Y);
              this.cycles += 2;
              break;

            case 0x88: // DEY
              this.Y = (this.Y - 1) & 0xff;
              this.setZN(this.Y);
              this.cycles += 2;
              break;

            case 0x1a: // INC A
              this.A = (this.A + 1) & 0xff;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0x3a: // DEC A
              this.A = (this.A - 1) & 0xff;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            // Arithmetic
            case 0x69: // ADC #imm
              const valADC = bus.read((this.PB << 16) | this.PC++);
              let sum = this.A + valADC + (this.P & FLAG.C ? 1 : 0);
              this.P = this.P & ~(FLAG.C | FLAG.V | FLAG.Z | FLAG.N);
              if (sum > 0xff) this.P |= FLAG.C;
              const result = sum & 0xff;
              if (~(this.A ^ valADC) & (this.A ^ result) & 0x80) this.P |= FLAG.V;
              this.A = result;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0xe9: // SBC #imm
              const valSBC = bus.read((this.PB << 16) | this.PC++);
              let diff = this.A - valSBC - (this.P & FLAG.C ? 0 : 1);
              this.P = this.P & ~(FLAG.C | FLAG.V | FLAG.Z | FLAG.N);
              if (diff >= 0) this.P |= FLAG.C;
              const resSBC = diff & 0xff;
              if ((this.A ^ valSBC) & (this.A ^ resSBC) & 0x80) this.P |= FLAG.V;
              this.A = resSBC;
              this.setZN(this.A);
              this.cycles += 2;
              break;
// MODIFY LDA immediate
case 0xa9:
  if (this.P & FLAG.M) {
    this.A = this.imm8(bus);
  } else {
    const lo = this.imm8(bus);
    const hi = this.imm8(bus);
    this.A = lo | (hi << 8);
  }
  this.setZN(this.A);
  this.cycles += 2;
  break;
// ADD REP / SEP
case 0xc2: this.P &= ~this.imm8(bus); break; // REP
case 0xe2: this.P |=  this.imm8(bus); break; // SEP

            // Logical operations
            case 0x29: // AND #imm
              this.A &= bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0x09: // ORA #imm
              this.A |= bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0x49: // EOR #imm
              this.A ^= bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.A);
              this.cycles += 2;
              break;

            // Compare operations
            case 0xc9: // CMP #imm
              const valCMP = bus.read((this.PB << 16) | this.PC++);
              const cmpRes = (this.A - valCMP) & 0xff;
              this.P = (this.P & ~(FLAG.C | FLAG.Z | FLAG.N));
              if (this.A >= valCMP) this.P |= FLAG.C;
              if (this.A === valCMP) this.P |= FLAG.Z;
              if (cmpRes & 0x80) this.P |= FLAG.N;
              this.cycles += 2;
              break;

            case 0xe0: // CPX #imm
              const valCPX = bus.read((this.PB << 16) | this.PC++);
              const cpxRes = (this.X - valCPX) & 0xff;
              this.P = (this.P & ~(FLAG.C | FLAG.Z | FLAG.N));
              if (this.X >= valCPX) this.P |= FLAG.C;
              if (this.X === valCPX) this.P |= FLAG.Z;
              if (cpxRes & 0x80) this.P |= FLAG.N;
              this.cycles += 2;
              break;

            case 0xc0: // CPY #imm
              const valCPY = bus.read((this.PB << 16) | this.PC++);
              const cpyRes = (this.Y - valCPY) & 0xff;
              this.P = (this.P & ~(FLAG.C | FLAG.Z | FLAG.N));
              if (this.Y >= valCPY) this.P |= FLAG.C;
              if (this.Y === valCPY) this.P |= FLAG.Z;
              if (cpyRes & 0x80) this.P |= FLAG.N;
              this.cycles += 2;
              break;

            // Bit test
            case 0x24: // BIT dp
              const dpBIT = bus.read((this.PB << 16) | this.PC++);
              const valBIT = bus.read((this.D + dpBIT) & 0xffff);
              this.P = (this.P & ~(FLAG.Z | FLAG.N | FLAG.V));
              if ((this.A & valBIT) === 0) this.P |= FLAG.Z;
              if (valBIT & 0x80) this.P |= FLAG.N;
              if (valBIT & 0x40) this.P |= FLAG.V;
              this.cycles += 3;
              break;

            // Branches
            case 0xf0: // BEQ
              const offBEQ = bus.read((this.PB << 16) | this.PC++);
              if (this.P & FLAG.Z) {
                this.PC = (this.PC + ((offBEQ << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0xd0: // BNE
              const offBNE = bus.read((this.PB << 16) | this.PC++);
              if (!(this.P & FLAG.Z)) {
                this.PC = (this.PC + ((offBNE << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x90: // BCC
              const offBCC = bus.read((this.PB << 16) | this.PC++);
              if (!(this.P & FLAG.C)) {
                this.PC = (this.PC + ((offBCC << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;
case 0x9C: { // STZ absolute
  const lo = this.read8(bus);
  const hi = this.read8(bus);
  const addr = (this.PB << 16) | (hi << 8) | lo;

  bus.write(addr, 0);
  bus.write(addr + 1, 0);

  this.cycles += 4;
  break;
}

            case 0xb0: // BCS
              const offBCS = bus.read((this.PB << 16) | this.PC++);
              if (this.P & FLAG.C) {
                this.PC = (this.PC + ((offBCS << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x30: // BMI
              const offBMI = bus.read((this.PB << 16) | this.PC++);
              if (this.P & FLAG.N) {
                this.PC = (this.PC + ((offBMI << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x10: // BPL
              const offBPL = bus.read((this.PB << 16) | this.PC++);
              if (!(this.P & FLAG.N)) {
                this.PC = (this.PC + ((offBPL << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x50: // BVC
              const offBVC = bus.read((this.PB << 16) | this.PC++);
              if (!(this.P & FLAG.V)) {
                this.PC = (this.PC + ((offBVC << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x70: // BVS
              const offBVS = bus.read((this.PB << 16) | this.PC++);
              if (this.P & FLAG.V) {
                this.PC = (this.PC + ((offBVS << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x80: // BRA
              const offBRA = bus.read((this.PB << 16) | this.PC++);
              this.PC = (this.PC + ((offBRA << 24) >> 24)) & 0xffff;
              this.cycles += 3;
              break;

            // Jumps and Calls
            case 0x4c: // JMP abs
              const loJMP = bus.read((this.PB << 16) | this.PC++);
              const hiJMP = bus.read((this.PB << 16) | this.PC++);
              this.PC = (hiJMP << 8) | loJMP;
              this.cycles += 3;
              break;

            case 0x20: // JSR abs
              const loJSR = bus.read((this.PB << 16) | this.PC++);
              const hiJSR = bus.read((this.PB << 16) | this.PC++);
              const ret = (this.PC - 1) & 0xffff;
              bus.write(0x100 | (this.S-- & 0xff), (ret >> 8) & 0xff);
              bus.write(0x100 | (this.S-- & 0xff), ret & 0xff);
              this.PC = (hiJSR << 8) | loJSR;
              this.cycles += 6;
              break;
// REP imm
case 0xC2: {
  const val = this.read8(bus);
  this.P &= ~val;
  this.updateWidthFlags();
  this.cycles += 3;
  break;
}

// SEP imm
case 0xE2: {
  const val = this.read8(bus);
  this.P |= val;
  this.updateWidthFlags();
  this.cycles += 3;
  break;
}

            case 0x60: // RTS
              const retLo = bus.read(0x100 | ((this.S + 1) & 0xff));
              this.S = (this.S + 1) & 0x1ff;
              const retHi = bus.read(0x100 | ((this.S + 1) & 0xff));
              this.S = (this.S + 1) & 0x1ff;
              this.PC = ((retHi << 8) | retLo) + 1;
              this.cycles += 6;
              break;

            // Stack operations
            case 0x48: // PHA
              bus.write(0x100 | (this.S-- & 0xff), this.A & 0xff);
              this.cycles += 3;
              break;

            case 0x68: // PLA
              this.S = (this.S + 1) & 0x1ff;
              this.A = bus.read(0x100 | (this.S & 0xff));
              this.setZN(this.A);
              this.cycles += 4;
              break;

            case 0x08: // PHP
              bus.write(0x100 | (this.S-- & 0xff), this.P);
              this.cycles += 3;
              break;

            case 0x28: // PLP
              this.S = (this.S + 1) & 0x1ff;
              this.P = bus.read(0x100 | (this.S & 0xff));
              this.cycles += 4;
              break;

            case 0xda: // PHX
              bus.write(0x100 | (this.S-- & 0xff), this.X & 0xff);
              this.cycles += 3;
              break;

            case 0xfa: // PLX
              this.S = (this.S + 1) & 0x1ff;
              this.X = bus.read(0x100 | (this.S & 0xff));
              this.setZN(this.X);
              this.cycles += 4;
              break;

            case 0x5a: // PHY
              bus.write(0x100 | (this.S-- & 0xff), this.Y & 0xff);
              this.cycles += 3;
              break;

            case 0x7a: // PLY
              this.S = (this.S + 1) & 0x1ff;
              this.Y = bus.read(0x100 | (this.S & 0xff));
              this.setZN(this.Y);
              this.cycles += 4;
              break;

            // Transfer operations
            case 0xaa: // TAX
              this.X = this.A;
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0xa8: // TAY
              this.Y = this.A;
              this.setZN(this.Y);
              this.cycles += 2;
              break;

            case 0x8a: // TXA
              this.A = this.X;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0x98: // TYA
              this.A = this.Y;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0xba: // TSX
              this.X = this.S & 0xff;
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0x9a: // TXS
              this.S = (this.S & 0x100) | this.X;
              this.cycles += 2;
              break;

            // Flag operations
            case 0x18: // CLC
              this.P &= ~FLAG.C;
              this.cycles += 2;
              break;

            case 0x38: // SEC
              this.P |= FLAG.C;
              this.cycles += 2;
              break;

            case 0x58: // CLI
              this.P &= ~FLAG.I;
              this.cycles += 2;
              break;

            case 0x78: // SEI
              this.P |= FLAG.I;
              this.cycles += 2;
              break;

            case 0xd8: // CLD
              this.P &= ~FLAG.D;
              this.cycles += 2;
              break;

            case 0xf8: // SED
              this.P |= FLAG.D;
              this.cycles += 2;
              break;

            case 0xb8: // CLV
              this.P &= ~FLAG.V;
              this.cycles += 2;
              break;

            // NOP
            case 0xea: // NOP
              this.cycles += 2;
              break;

            default:
              this.cycles += 2;
              break;
          }}
      };

      class Bus {
        constructor(rom, ppu) {
          this.rom = rom;
          this.ppu = ppu;
          this.vramAddr = 0;
          this.cgramAddr = 0;
          this.oamAddr = 0;
          // ADD at top of Bus constructor
this.wram = new Uint8Array(128 * 1024); // 128KB WRAM
this.joypad1 = 0;
this.joypadShift = 0;
this.nmiFlag = false;
// ADD
this.vramInc = 1;
this.vramLowHigh = 0;

this.dma = {
  enabled: false,
  src: 0,
  dst: 0,
  size: 0,
  mode: 0
};

        }
       read(addr) {
  addr &= 0xffffff;

// --- LoROM ---
const bankn = (addr >> 16) & 0xff;
const offs = addr & 0xffff;

if (offs >= 0x8000 && bankn <= 0x7d) {
  const romAddr = ((bankn * 0x8000) + (offs & 0x7fff));
  if (romAddr < this.rom.length) {
    return this.rom[romAddr];
  }
}


  // --- WRAM ---
  if (addr < 0x200000) {
    return this.wram[addr & 0x1ffff];
  }
if (addr === 0x4212) { // HVBJOY
  return this.ppu.vblank ? 0x80 : 0x00;
}

  // --- PPU I/O ---
  if (addr === 0x4210) {
    const v = this.nmiFlag ? 0x80 : 0;
    this.nmiFlag = false;
    return v;
  }
if (addr === 0x2115) { // VMAIN
  const incTable = [1, 32, 128, 128];
  this.vramInc = incTable[val & 0x03];
  this.vramLowHigh = (val >> 7) & 1;
  return;
}
if (addr === 0x4210) { // RDNMI
  const v = this.ppu.vblank ? 0x80 : 0x00;
  this.ppu.vblank = false; // 読むとクリア
  return v;
}

  // --- Controller ---
  if (addr === 0x4016) {
    const v = (this.joypadShift & 1);
    this.joypadShift >>= 1;
    return v;
  }

  // --- ROM (LoROM) ---
  const bank = addr >> 16;
  const ofs = addr & 0x7fff;
  if (ofs >= 0x8000) {
    return this.rom[(bank * 0x8000 + ofs - 0x8000) % this.rom.length];
  }

  return 0;
}
// ADD
runDMA() {
  let src = this.dma.src;
  let dst = this.dma.dst;
  let size = this.dma.size || 0x10000;

  for (let i = 0; i < size; i++) {
    const data = this.read(src);

    // --- 転送先 ---
    switch (dst) {
      case 0x2118: // VRAM low
      case 0x2119: // VRAM high
      case 0x2122: // CGRAM
      case 0x2104: // OAM
        this.write(dst, data);
        break;
    }

    src = (src + 1) & 0xffffff;
  }
}

       write(addr, val) {
  addr &= 0xffffff;
  if (addr === 0x420b) {
  console.log("DMA START WRITE", val);
}
if ((addr & 0xffff) === 0x420b) {
  console.log("DMA START WRITE", val);
  this.runDMA();
  return;
}

if (addr === 0x2100) {
  console.log("INIDISP WRITE", val.toString(16));
}
if (addr >= 0x2000 && addr <= 0x21ff) {
  console.log("WRITE IO", addr.toString(16), val.toString(16));
}

  // --- WRAM ---
  // --- WRAM (正しい範囲) ---
if (addr >= 0x7e0000 && addr <= 0x7fffff) {
  this.wram[addr & 0x1ffff] = val;
  return;
}

if (addr === 0x2105) { // BGMODE
  this.ppu.bgMode = val & 0x07;
  return;
}

if (addr === 0x2107) { // BG1SC (tilemap base)
  this.ppu.bg1MapBase = (val & 0x7C) << 9; // ×0x400
  return;
}

if (addr === 0x210B) { // BG12NBA (tile data base)
  this.ppu.bg1TileBase = (val & 0x0F) << 13; // ×0x2000
  return;
}

  // --- Controller latch ---
  if (addr === 0x4016) {
    if (val & 1) this.joypadShift = this.joypad1;
    return;
  }
// ADD in Bus.write()
if (addr === 0x2100) { // INIDISP
  this.ppu.inidisp = val;
  return;
}

// --- DMA registers ---
if (addr === 0x4300) {        // DMAP0
  this.dma.mode = val;
  return;
}
if (addr === 0x4301) {        // BBAD0
  this.dma.dst = 0x2100 | val;
  return;
}
if (addr === 0x4302) {        // A1T0L
  this.dma.src = (this.dma.src & 0xffff00) | val;
  return;
}
if (addr === 0x4303) {        // A1T0H
  this.dma.src = (this.dma.src & 0xff00ff) | (val << 8);
  return;
}
if (addr === 0x4304) {        // A1B0
  this.dma.src = (this.dma.src & 0x00ffff) | (val << 16);
  return;
}
if (addr === 0x4305) {        // DAS0L
  this.dma.size = (this.dma.size & 0xff00) | val;
  return;
}
if (addr === 0x4306) {        // DAS0H
  this.dma.size = (this.dma.size & 0x00ff) | (val << 8);
  return;
}
if (addr === 0x420b && (val & 1)) {
  this.runDMA();
  return;
}

  // --- 既存PPU処理はそのまま ---

          switch (addr) {
            // --- VRAM ---
            case 0x2107: // BG1SC
  this.ppu.bg1MapBase = (val & 0x7c) << 8;
  break;
case 0x210b: // BG12NBA
  this.ppu.bg1TileBase = (val & 0x0f) << 12;
  break;
case 0x212c: // TM - Main Screen
  this.ppu.mainScreen = val;
  break;

case 0x212d: // TS - Sub Screen
  this.ppu.subScreen = val;
  break;

            case 0x2116: // VRAMアドレス低位
              this.vramAddr = (this.vramAddr & 0xff00) | val;
              break;
            case 0x2117: // VRAMアドレス高位
              this.vramAddr = (this.vramAddr & 0x00ff) | (val << 8);
              break;
           case 0x2118: // VRAM low
  this.ppu.writeVRAM(this.vramAddr, val);
  if (this.vramLowHigh === 0) {
    this.vramAddr = (this.vramAddr + this.vramInc) & 0xffff;
  }
  break;

case 0x2119: // VRAM high
  this.ppu.writeVRAM(this.vramAddr + 1, val);
  if (this.vramLowHigh === 1) {
    this.vramAddr = (this.vramAddr + this.vramInc) & 0xffff;
  }
  break;


            // --- CGRAM ---

            case 0x2121: // CGRAMアドレス
              this.cgramAddr = val & 0x1ff;
              break;
            case 0x2122: // CGRAMデータ
              this.ppu.writeCGRAM(this.cgramAddr, val);
              this.cgramAddr = (this.cgramAddr + 1) & 0x1ff;
              break;

            // --- OAM ---
            case 0x2102: // OAMアドレス低位
              this.oamAddr = (this.oamAddr & 0xff00) | val;
              break;
            case 0x2103: // OAMアドレス高位
              this.oamAddr = (this.oamAddr & 0x00ff) | ((val & 0x01) << 8);
              break;
            case 0x2104: // OAMデータ
              this.ppu.writeOAM(this.oamAddr, val);
              this.oamAddr = (this.oamAddr + 1) % 544;
              break;

            default:
              // ROM以外の領域は無視
              break;
          }
          // ROMなので無視、後でWRAMやI/Oを追加
        }
      }
      let romData = null;
     function resetCPU(cpu, romData, mapping = "LoROM") {
  const hasHeader = (romData.length & 0x7fff) === 512;
  const off = hasHeader ? 0x200 : 0;

  let lo, hi;
  if (mapping === "LoROM") {
    lo = romData[off + 0x7ffc];
    hi = romData[off + 0x7ffd];
  } else {
    lo = romData[off + 0xfffc];
    hi = romData[off + 0xfffd];
  }

  cpu.PC = (hi << 8) | lo;
  cpu.PB = 0x00;
  cpu.S  = 0x1ff;
  cpu.P  = 0x34;
  cpu.emulation = true;

  console.log("RESET PC =", cpu.PC.toString(16));
}


      document.getElementById("rom").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        romData = new Uint8Array(await file.arrayBuffer());
        document.getElementById(
          "status"
        ).textContent;
        document.getElementById("start").disabled = false;
      });

      function run(cpu, bus, cycles = 1000) {
        for (let i = 0; i < cycles; i++) {
          cpu.step(bus);
        }
      }
      // ADD globally
const keys = {};
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);


      document.getElementById("start").addEventListener("click", () => {
        const canvas = document.getElementById("screen");

        const cpu = new CPU65C816();
        const ctx = canvas.getContext("2d");
        const ppu = new PPU(ctx);
        const bus = new Bus(romData, ppu);
        //cpu.reset(bus);

        resetCPU(cpu, romData, "LoROM");
        ppu.reset();
        // ADD before frame()
bus.joypad1 =
  (keys.ArrowRight ? 1 << 0 : 0) |
  (keys.ArrowLeft  ? 1 << 1 : 0) |
  (keys.ArrowDown  ? 1 << 2 : 0) |
  (keys.ArrowUp    ? 1 << 3 : 0) |
  (keys.KeyZ       ? 1 << 4 : 0) |
  (keys.KeyX       ? 1 << 5 : 0) |
  (keys.Enter      ? 1 << 7 : 0);

        function frame() {
          // MODIFY frame()
// FORCE background color (青)

for (let i = 0; i < 20000; i++) cpu.step(bus);
ppu.startVBlank(bus);
// MODIFY frame()

ppu.renderSprites();
//bus.write(0x2100, 0x0F); // brightness max, screen ON

document.getElementById("addr").textContent="0x"+cpu.PC.toString(16)+":0x"+cpu.PC.toString(16);
          // CPUがCGRAMに色を書き込む（青色）
console.log(ppu.cgram.slice(0, 4));


console.log(ppu.inidisp);


          // 背景色を描画
          ppu.renderBGColor();
          ppu.renderBG1(); // 後で本物の描画に置き換える
          //updateDebug(cpu);
          requestAnimationFrame(frame);
        }

        frame();
      });
    </script>
  </body>
</html>