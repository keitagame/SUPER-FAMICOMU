<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>SNES by keita</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
  :root {
        color-scheme: light dark;
      }
      body {
        background:rgb(0, 0, 0);
        font-family: ui-sans-serif, system-ui;
        margin: 16px;
      }
      header {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
      }
      canvas{
        
        height: 100%;              /* コンテナ幅に合わせる */
      aspect-ratio: 256 / 240;  /* 内部解像度の比率を維持 */
        image-rendering: pixelated;
        border: 1px solid #000000;
        background: #000;
      }
      .row div{
        display:none;
      }
      .row {
        padding-top:0px;
height:83vh;
justify-content: center; 
        display: flex;
        gap: 12px;
        align-items: center;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
      small {
        opacity: 0.7;
      }
      #romSelect{
display:none;
}
button{
padding:10px;
background:rgb(0, 0, 0);
color:rgb(255, 255, 255);
border:1px solid rgb(255, 255, 255);
}
    </style>
  </head>
  <body>
    <header>
      <input id="rom" type="file" accept=".sfc" />
      <button id="fullscreenBtn">Fullscreen</button>

      <button id="start" disabled>Start</button>
      <div class="mono" id="status">No ROM</div>
      <div class="mono" id="addr">0x0000</div>
      <input type="text" id="myInput" value="30" />
    </header>
    <div class="row">
      <canvas id="screen" width="256" height="240"></canvas>
      <div>
        <div><b>FPS:</b> <span id="fps">0</span></div>
        <div><b>CPU PC:</b> <span id="pc" class="mono">0x0000</span></div>
        <div><b>Cycles:</b> <span id="cyc" class="mono">0</span></div>
        <div><b>VRAM V:</b><span id="pcp" class="mono">0x0000</span></div>
        <div><b>VRAM T:</b><span id="ppx" class="mono">0x0000</span></div>
        <div><b>CPU S:</b><span id="ram" class="mono">0x0000</span></div>
        <div><b>CPU P:</b><span id="mapper" class="mono">0x0000</span></div>
        <div><b>APU M:</b><span id="apu" class="mono">0x0000</span></div>
        <small
          >Skeleton: Mapper0, iNES, PPU frame timing + NMI, CPU bus/IRQs, opcode
          hooks</small
        >
      </div>
    </div>

    

    <script type="module">
      class PPU {
        constructor(ctx) {
          this.ctx = ctx;
          this.width = 256;
          this.height = 224;
          this.vram = new Uint8Array(64 * 1024); // 64KB
          this.cgram = new Uint8Array(512); // 512B
          this.oam = new Uint8Array(544); // 544B
          this.inidisp = 0x80; // 画面OFF
          this.bgmode = 0; // モード0
          // --- フレームバッファ ---
          // モード0
          this.vramAddr = 0;
          this.cgramAddr = 0;
          this.oamAddr = 0;
          this.bg1ScrollX = 0;
          this.bg1ScrollY = 0;
          this.buffer = new Uint32Array(this.width * this.height);
          this.imageData = ctx.createImageData(this.width, this.height);
        }
        reset() {
          // メモリクリア
          this.vram.fill(0);
          this.cgram.fill(0);
          this.oam.fill(0);

          // レジスタ初期化
          this.inidisp = 0x80; // 画面OFF
          this.bgmode = 0;
          this.vramAddr = 0;
          this.cgramAddr = 0;
          this.oamAddr = 0;

          // 背景を黒で塗る
          this.buffer.fill(0xff000000);
          this.flush();
        }
        writeVRAM(addr, value) {
          this.vram[addr & 0xffff] = value;
        }

        readVRAM(addr) {
          return this.vram[addr & 0xffff];
        }

        // CGRAM書き込み（パレット）
        writeCGRAM(addr, value) {
          this.cgram[addr & 0x1ff] = value;
        }

        readCGRAM(addr) {
          return this.cgram[addr & 0x1ff];
        }

        // OAM書き込み（スプライト属性）
        writeOAM(addr, value) {
          this.oam[addr % 544] = value;
        }

        readOAM(addr) {
          return this.oam[addr % 544];
        }
        getColor(index) {
          const lo = this.cgram[index * 2];
          const hi = this.cgram[index * 2 + 1];
          const color = lo | (hi << 8);
          const r = (color & 0x1f) << 3;
          const g = ((color >> 5) & 0x1f) << 3;
          const b = ((color >> 10) & 0x1f) << 3;
          return (255 << 24) | (b << 16) | (g << 8) | r;
        }
// ADD
renderSprites() {
  for (let i = 0; i < 128; i++) {
    const o = i * 4;
    const y = this.oam[o];
    const tile = this.oam[o + 1];
    const attr = this.oam[o + 2];
    const x = this.oam[o + 3];
    const pal = attr & 0x7;
    this.drawTile(tile, pal, x, y);
  }
}

        // --- タイル1枚を描画 ---
        drawTile(tileIndex, paletteIndex, dx, dy) {
          const base = tileIndex * 32; // 1タイル=32バイト
          for (let row = 0; row < 8; row++) {
            // 4bpp: 2bitplane×2
            const p0 = this.vram[base + row * 2];
            const p1 = this.vram[base + row * 2 + 1];
            const p2 = this.vram[base + 16 + row * 2];
            const p3 = this.vram[base + 16 + row * 2 + 1];
            for (let col = 0; col < 8; col++) {
              const bit = 7 - col;
              const colorIndex =
                ((p0 >> bit) & 1) |
                (((p1 >> bit) & 1) << 1) |
                (((p2 >> bit) & 1) << 2) |
                (((p3 >> bit) & 1) << 3);
              if (colorIndex === 0) continue; // 透明色
              const paletteColor = this.getColor(
                paletteIndex * 16 + colorIndex
              );
              this.buffer[(dy + row) * this.width + (dx + col)] = paletteColor;
            }
          }
        }

        // --- 背景マップを描画 ---
        renderBG1() {
          const col = this.getColor(0);
          // 仮にVRAMの0x0000にBGマップがあるとする
          const mapBase = 0x0000;
          for (let ty = 0; ty < 28; ty++) {
            for (let tx = 0; tx < 32; tx++) {
              const addr = mapBase + (ty * 32 + tx) * 2;
              const tileIndex =
                this.vram[addr] | ((this.vram[addr + 1] & 0x03) << 8);
              const paletteIndex = (this.vram[addr + 1] >> 2) & 0x07;
              this.drawTile(tileIndex, paletteIndex, tx * 8, ty * 8);
            }
          }
          this.flush();
        }
        // テスト用: グラデーション描画
        setScrollX(val) {
          this.bg1ScrollX = val;
        }
        setScrollY(val) {
          this.bg1ScrollY = val;
        }
// ADD in PPU
startVBlank(bus) {
  bus.nmiFlag = true;
}

        renderBG1() {
          const mapBase = 0x0000;
          for (let ty = 0; ty < 28; ty++) {
            for (let tx = 0; tx < 32; tx++) {
              const addr = mapBase + (ty * 32 + tx) * 2;
              const tileIndex =
                this.vram[addr] | ((this.vram[addr + 1] & 0x03) << 8);
              const paletteIndex = (this.vram[addr + 1] >> 2) & 0x07;
              this.drawTile(
                tileIndex,
                paletteIndex,
                tx * 8 - this.bg1ScrollX,
                ty * 8 - this.bg1ScrollY
              );
            }
          }
          this.flush();
        }
        renderBGColor() {
          const col = this.getColor(0); // パレット0番を背景色に
          this.buffer.fill(col);
          this.flush();
        }
        flush() {
          const buf8 = new Uint8ClampedArray(this.buffer.buffer);
          this.imageData.data.set(buf8);
          this.ctx.putImageData(this.imageData, 0, 0);
        }
      }

      const FLAG = {
        C: 1 << 0,
        Z: 1 << 1,
        I: 1 << 2,
        D: 1 << 3,
        X: 1 << 4,
        M: 1 << 5,
        V: 1 << 6,
        N: 1 << 7,
      };
      class CPU65C816 {
        constructor() {
          this.PC = 0x8000;
          this.A = 0;
          this.X = 0;
          this.Y = 0;
          this.S = 0x1ff;
          this.D = 0;
          this.DB = 0;
          this.PB = 0;
          this.P = 0x34;
          this.emulation = true;
          this.cycles = 0;
        }
        // ADD inside CPU class
read16(bus, addr) {
  const lo = bus.read(addr);
  const hi = bus.read((addr + 1) & 0xffff);
  return lo | (hi << 8);
}

imm8(bus) {
  return bus.read((this.PB << 16) | this.PC++);
}

abs(bus) {
  const lo = this.imm8(bus);
  const hi = this.imm8(bus);
  return (this.DB << 16) | (hi << 8) | lo;
}

        setZN(value) {
          if ((value & 0xff) === 0) {
            this.P |= FLAG.Z;
          } else {
            this.P &= ~FLAG.Z;
          }
          if (value & 0x80) {
            this.P |= FLAG.N;
          } else {
            this.P &= ~FLAG.N;
          }
        }

        step(bus) {
          const opcode = bus.read((this.PB << 16) | this.PC);
          this.PC = (this.PC + 1) & 0xffff;
// ADD at top of CPU.step()
if (bus.nmiFlag && !(this.P & FLAG.I)) {
  bus.nmiFlag = false;

  bus.write(0x100 | (this.S-- & 0xff), (this.PC >> 8) & 0xff);
  bus.write(0x100 | (this.S-- & 0xff), this.PC & 0xff);
  bus.write(0x100 | (this.S-- & 0xff), this.P);

  const lo = bus.read(0xffea);
  const hi = bus.read(0xffeb);
  this.PC = lo | (hi << 8);
  this.cycles += 7;
  return;
}

          switch (opcode) {
            // Load/Store operations
            case 0xa9: // LDA #imm
              this.A = bus.read((this.PB << 16) | this.PC);
              this.PC = (this.PC + 1) & 0xffff;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0xa5: // LDA dp
              const dpA = bus.read((this.PB << 16) | this.PC++);
              this.A = bus.read((this.D + dpA) & 0xffff);
              this.setZN(this.A);
              this.cycles += 3;
              break;

            case 0xad: // LDA abs
              const loA = bus.read((this.PB << 16) | this.PC++);
              const hiA = bus.read((this.PB << 16) | this.PC++);
              this.A = bus.read((hiA << 8) | loA);
              this.setZN(this.A);
              this.cycles += 4;
              break;

            case 0xa2: // LDX #imm
              this.X = bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0xa6: // LDX dp
              const dpX = bus.read((this.PB << 16) | this.PC++);
              this.X = bus.read((this.D + dpX) & 0xffff);
              this.setZN(this.X);
              this.cycles += 3;
              break;

            case 0xae: // LDX abs
              const loLX = bus.read((this.PB << 16) | this.PC++);
              const hiLX = bus.read((this.PB << 16) | this.PC++);
              this.X = bus.read((hiLX << 8) | loLX);
              this.setZN(this.X);
              this.cycles += 4;
              break;

            case 0xa0: // LDY #imm
              this.Y = bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.Y);
              this.cycles += 2;
              break;
// ADD opcode
case 0xbd: { // LDA abs,X
  const base = this.abs(bus);
  this.A = bus.read((base + this.X) & 0xffffff);
  this.setZN(this.A);
  this.cycles += 4;
  break;
}

            case 0xa4: // LDY dp
              const dpY = bus.read((this.PB << 16) | this.PC++);
              this.Y = bus.read((this.D + dpY) & 0xffff);
              this.setZN(this.Y);
              this.cycles += 3;
              break;

            case 0xac: // LDY abs
              const loLY = bus.read((this.PB << 16) | this.PC++);
              const hiLY = bus.read((this.PB << 16) | this.PC++);
              this.Y = bus.read((hiLY << 8) | loLY);
              this.setZN(this.Y);
              this.cycles += 4;
              break;

            case 0x85: // STA dp
              const dpSA = bus.read((this.PB << 16) | this.PC++);
              bus.write((this.D + dpSA) & 0xffff, this.A & 0xff);
              this.cycles += 3;
              break;

            case 0x8d: // STA abs
              const loSA = bus.read((this.PB << 16) | this.PC++);
              const hiSA = bus.read((this.PB << 16) | this.PC++);
              bus.write((hiSA << 8) | loSA, this.A & 0xff);
              this.cycles += 4;
              break;

            case 0x86: // STX dp
              const dpSX = bus.read((this.PB << 16) | this.PC++);
              bus.write((this.D + dpSX) & 0xffff, this.X & 0xff);
              this.cycles += 3;
              break;

            case 0x8e: // STX abs
              const loSX = bus.read((this.PB << 16) | this.PC++);
              const hiSX = bus.read((this.PB << 16) | this.PC++);
              bus.write((hiSX << 8) | loSX, this.X & 0xff);
              this.cycles += 4;
              break;

            case 0x84: // STY dp
              const dpSY = bus.read((this.PB << 16) | this.PC++);
              bus.write((this.D + dpSY) & 0xffff, this.Y & 0xff);
              this.cycles += 3;
              break;

            case 0x8c: // STY abs
              const loSY = bus.read((this.PB << 16) | this.PC++);
              const hiSY = bus.read((this.PB << 16) | this.PC++);
              bus.write((hiSY << 8) | loSY, this.Y & 0xff);
              this.cycles += 4;
              break;

            // Increment/Decrement
            case 0xe8: // INX
              this.X = (this.X + 1) & 0xff;
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0xca: // DEX
              this.X = (this.X - 1) & 0xff;
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0xc8: // INY
              this.Y = (this.Y + 1) & 0xff;
              this.setZN(this.Y);
              this.cycles += 2;
              break;

            case 0x88: // DEY
              this.Y = (this.Y - 1) & 0xff;
              this.setZN(this.Y);
              this.cycles += 2;
              break;

            case 0x1a: // INC A
              this.A = (this.A + 1) & 0xff;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0x3a: // DEC A
              this.A = (this.A - 1) & 0xff;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            // Arithmetic
            case 0x69: // ADC #imm
              const valADC = bus.read((this.PB << 16) | this.PC++);
              let sum = this.A + valADC + (this.P & FLAG.C ? 1 : 0);
              this.P = this.P & ~(FLAG.C | FLAG.V | FLAG.Z | FLAG.N);
              if (sum > 0xff) this.P |= FLAG.C;
              const result = sum & 0xff;
              if (~(this.A ^ valADC) & (this.A ^ result) & 0x80) this.P |= FLAG.V;
              this.A = result;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0xe9: // SBC #imm
              const valSBC = bus.read((this.PB << 16) | this.PC++);
              let diff = this.A - valSBC - (this.P & FLAG.C ? 0 : 1);
              this.P = this.P & ~(FLAG.C | FLAG.V | FLAG.Z | FLAG.N);
              if (diff >= 0) this.P |= FLAG.C;
              const resSBC = diff & 0xff;
              if ((this.A ^ valSBC) & (this.A ^ resSBC) & 0x80) this.P |= FLAG.V;
              this.A = resSBC;
              this.setZN(this.A);
              this.cycles += 2;
              break;
// MODIFY LDA immediate
case 0xa9:
  if (this.P & FLAG.M) {
    this.A = this.imm8(bus);
  } else {
    const lo = this.imm8(bus);
    const hi = this.imm8(bus);
    this.A = lo | (hi << 8);
  }
  this.setZN(this.A);
  this.cycles += 2;
  break;
// ADD REP / SEP
case 0xc2: this.P &= ~this.imm8(bus); break; // REP
case 0xe2: this.P |=  this.imm8(bus); break; // SEP

            // Logical operations
            case 0x29: // AND #imm
              this.A &= bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0x09: // ORA #imm
              this.A |= bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0x49: // EOR #imm
              this.A ^= bus.read((this.PB << 16) | this.PC++);
              this.setZN(this.A);
              this.cycles += 2;
              break;

            // Compare operations
            case 0xc9: // CMP #imm
              const valCMP = bus.read((this.PB << 16) | this.PC++);
              const cmpRes = (this.A - valCMP) & 0xff;
              this.P = (this.P & ~(FLAG.C | FLAG.Z | FLAG.N));
              if (this.A >= valCMP) this.P |= FLAG.C;
              if (this.A === valCMP) this.P |= FLAG.Z;
              if (cmpRes & 0x80) this.P |= FLAG.N;
              this.cycles += 2;
              break;

            case 0xe0: // CPX #imm
              const valCPX = bus.read((this.PB << 16) | this.PC++);
              const cpxRes = (this.X - valCPX) & 0xff;
              this.P = (this.P & ~(FLAG.C | FLAG.Z | FLAG.N));
              if (this.X >= valCPX) this.P |= FLAG.C;
              if (this.X === valCPX) this.P |= FLAG.Z;
              if (cpxRes & 0x80) this.P |= FLAG.N;
              this.cycles += 2;
              break;

            case 0xc0: // CPY #imm
              const valCPY = bus.read((this.PB << 16) | this.PC++);
              const cpyRes = (this.Y - valCPY) & 0xff;
              this.P = (this.P & ~(FLAG.C | FLAG.Z | FLAG.N));
              if (this.Y >= valCPY) this.P |= FLAG.C;
              if (this.Y === valCPY) this.P |= FLAG.Z;
              if (cpyRes & 0x80) this.P |= FLAG.N;
              this.cycles += 2;
              break;

            // Bit test
            case 0x24: // BIT dp
              const dpBIT = bus.read((this.PB << 16) | this.PC++);
              const valBIT = bus.read((this.D + dpBIT) & 0xffff);
              this.P = (this.P & ~(FLAG.Z | FLAG.N | FLAG.V));
              if ((this.A & valBIT) === 0) this.P |= FLAG.Z;
              if (valBIT & 0x80) this.P |= FLAG.N;
              if (valBIT & 0x40) this.P |= FLAG.V;
              this.cycles += 3;
              break;

            // Branches
            case 0xf0: // BEQ
              const offBEQ = bus.read((this.PB << 16) | this.PC++);
              if (this.P & FLAG.Z) {
                this.PC = (this.PC + ((offBEQ << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0xd0: // BNE
              const offBNE = bus.read((this.PB << 16) | this.PC++);
              if (!(this.P & FLAG.Z)) {
                this.PC = (this.PC + ((offBNE << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x90: // BCC
              const offBCC = bus.read((this.PB << 16) | this.PC++);
              if (!(this.P & FLAG.C)) {
                this.PC = (this.PC + ((offBCC << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0xb0: // BCS
              const offBCS = bus.read((this.PB << 16) | this.PC++);
              if (this.P & FLAG.C) {
                this.PC = (this.PC + ((offBCS << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x30: // BMI
              const offBMI = bus.read((this.PB << 16) | this.PC++);
              if (this.P & FLAG.N) {
                this.PC = (this.PC + ((offBMI << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x10: // BPL
              const offBPL = bus.read((this.PB << 16) | this.PC++);
              if (!(this.P & FLAG.N)) {
                this.PC = (this.PC + ((offBPL << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x50: // BVC
              const offBVC = bus.read((this.PB << 16) | this.PC++);
              if (!(this.P & FLAG.V)) {
                this.PC = (this.PC + ((offBVC << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x70: // BVS
              const offBVS = bus.read((this.PB << 16) | this.PC++);
              if (this.P & FLAG.V) {
                this.PC = (this.PC + ((offBVS << 24) >> 24)) & 0xffff;
                this.cycles += 1;
              }
              this.cycles += 2;
              break;

            case 0x80: // BRA
              const offBRA = bus.read((this.PB << 16) | this.PC++);
              this.PC = (this.PC + ((offBRA << 24) >> 24)) & 0xffff;
              this.cycles += 3;
              break;

            // Jumps and Calls
            case 0x4c: // JMP abs
              const loJMP = bus.read((this.PB << 16) | this.PC++);
              const hiJMP = bus.read((this.PB << 16) | this.PC++);
              this.PC = (hiJMP << 8) | loJMP;
              this.cycles += 3;
              break;

            case 0x20: // JSR abs
              const loJSR = bus.read((this.PB << 16) | this.PC++);
              const hiJSR = bus.read((this.PB << 16) | this.PC++);
              const ret = (this.PC - 1) & 0xffff;
              bus.write(0x100 | (this.S-- & 0xff), (ret >> 8) & 0xff);
              bus.write(0x100 | (this.S-- & 0xff), ret & 0xff);
              this.PC = (hiJSR << 8) | loJSR;
              this.cycles += 6;
              break;

            case 0x60: // RTS
              const retLo = bus.read(0x100 | ((this.S + 1) & 0xff));
              this.S = (this.S + 1) & 0x1ff;
              const retHi = bus.read(0x100 | ((this.S + 1) & 0xff));
              this.S = (this.S + 1) & 0x1ff;
              this.PC = ((retHi << 8) | retLo) + 1;
              this.cycles += 6;
              break;

            // Stack operations
            case 0x48: // PHA
              bus.write(0x100 | (this.S-- & 0xff), this.A & 0xff);
              this.cycles += 3;
              break;

            case 0x68: // PLA
              this.S = (this.S + 1) & 0x1ff;
              this.A = bus.read(0x100 | (this.S & 0xff));
              this.setZN(this.A);
              this.cycles += 4;
              break;

            case 0x08: // PHP
              bus.write(0x100 | (this.S-- & 0xff), this.P);
              this.cycles += 3;
              break;

            case 0x28: // PLP
              this.S = (this.S + 1) & 0x1ff;
              this.P = bus.read(0x100 | (this.S & 0xff));
              this.cycles += 4;
              break;

            case 0xda: // PHX
              bus.write(0x100 | (this.S-- & 0xff), this.X & 0xff);
              this.cycles += 3;
              break;

            case 0xfa: // PLX
              this.S = (this.S + 1) & 0x1ff;
              this.X = bus.read(0x100 | (this.S & 0xff));
              this.setZN(this.X);
              this.cycles += 4;
              break;

            case 0x5a: // PHY
              bus.write(0x100 | (this.S-- & 0xff), this.Y & 0xff);
              this.cycles += 3;
              break;

            case 0x7a: // PLY
              this.S = (this.S + 1) & 0x1ff;
              this.Y = bus.read(0x100 | (this.S & 0xff));
              this.setZN(this.Y);
              this.cycles += 4;
              break;

            // Transfer operations
            case 0xaa: // TAX
              this.X = this.A;
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0xa8: // TAY
              this.Y = this.A;
              this.setZN(this.Y);
              this.cycles += 2;
              break;

            case 0x8a: // TXA
              this.A = this.X;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0x98: // TYA
              this.A = this.Y;
              this.setZN(this.A);
              this.cycles += 2;
              break;

            case 0xba: // TSX
              this.X = this.S & 0xff;
              this.setZN(this.X);
              this.cycles += 2;
              break;

            case 0x9a: // TXS
              this.S = (this.S & 0x100) | this.X;
              this.cycles += 2;
              break;

            // Flag operations
            case 0x18: // CLC
              this.P &= ~FLAG.C;
              this.cycles += 2;
              break;

            case 0x38: // SEC
              this.P |= FLAG.C;
              this.cycles += 2;
              break;

            case 0x58: // CLI
              this.P &= ~FLAG.I;
              this.cycles += 2;
              break;

            case 0x78: // SEI
              this.P |= FLAG.I;
              this.cycles += 2;
              break;

            case 0xd8: // CLD
              this.P &= ~FLAG.D;
              this.cycles += 2;
              break;

            case 0xf8: // SED
              this.P |= FLAG.D;
              this.cycles += 2;
              break;

            case 0xb8: // CLV
              this.P &= ~FLAG.V;
              this.cycles += 2;
              break;

            // NOP
            case 0xea: // NOP
              this.cycles += 2;
              break;

            default:
              this.cycles += 2;
              break;
          }}
      };

      class Bus {
        constructor(rom, ppu) {
          this.rom = rom;
          this.ppu = ppu;
          this.vramAddr = 0;
          this.cgramAddr = 0;
          this.oamAddr = 0;
          // ADD at top of Bus constructor
this.wram = new Uint8Array(128 * 1024); // 128KB WRAM
this.joypad1 = 0;
this.joypadShift = 0;
this.nmiFlag = false;

        }
       read(addr) {
  addr &= 0xffffff;

  // --- WRAM ---
  if (addr < 0x200000) {
    return this.wram[addr & 0x1ffff];
  }

  // --- PPU I/O ---
  if (addr === 0x4210) {
    const v = this.nmiFlag ? 0x80 : 0;
    this.nmiFlag = false;
    return v;
  }

  // --- Controller ---
  if (addr === 0x4016) {
    const v = (this.joypadShift & 1);
    this.joypadShift >>= 1;
    return v;
  }

  // --- ROM (LoROM) ---
  const bank = addr >> 16;
  const ofs = addr & 0x7fff;
  if (ofs >= 0x8000) {
    return this.rom[(bank * 0x8000 + ofs - 0x8000) % this.rom.length];
  }

  return 0;
}

       write(addr, val) {
  addr &= 0xffffff;

  // --- WRAM ---
  if (addr < 0x200000) {
    this.wram[addr & 0x1ffff] = val;
    return;
  }

  // --- Controller latch ---
  if (addr === 0x4016) {
    if (val & 1) this.joypadShift = this.joypad1;
    return;
  }

  // --- 既存PPU処理はそのまま ---

          switch (addr) {
            // --- VRAM ---
            case 0x2116: // VRAMアドレス低位
              this.vramAddr = (this.vramAddr & 0xff00) | val;
              break;
            case 0x2117: // VRAMアドレス高位
              this.vramAddr = (this.vramAddr & 0x00ff) | (val << 8);
              break;
            case 0x2118: // VRAMデータポート (低位)
              this.ppu.writeVRAM(this.vramAddr, val);
              this.vramAddr = (this.vramAddr + 1) & 0xffff;
              break;
            case 0x2119: // VRAMデータポート (高位)
              this.ppu.writeVRAM(this.vramAddr, val);
              this.vramAddr = (this.vramAddr + 1) & 0xffff;
              break;

            // --- CGRAM ---

            case 0x2121: // CGRAMアドレス
              this.cgramAddr = val & 0x1ff;
              break;
            case 0x2122: // CGRAMデータ
              this.ppu.writeCGRAM(this.cgramAddr, val);
              this.cgramAddr = (this.cgramAddr + 1) & 0x1ff;
              break;

            // --- OAM ---
            case 0x2102: // OAMアドレス低位
              this.oamAddr = (this.oamAddr & 0xff00) | val;
              break;
            case 0x2103: // OAMアドレス高位
              this.oamAddr = (this.oamAddr & 0x00ff) | ((val & 0x01) << 8);
              break;
            case 0x2104: // OAMデータ
              this.ppu.writeOAM(this.oamAddr, val);
              this.oamAddr = (this.oamAddr + 1) % 544;
              break;

            default:
              // ROM以外の領域は無視
              break;
          }
          // ROMなので無視、後でWRAMやI/Oを追加
        }
      }
      let romData = null;
      function resetCPU(cpu, romData, mapping = "LoROM") {
        let lo, hi;

        if (mapping === "LoROM") {
          lo = romData[0x7ffc];
          hi = romData[0x7ffd];
        } else if (mapping === "HiROM") {
          lo = romData[0xfffc];
          hi = romData[0xfffd];
        } else {
          throw new Error("Unknown mapping type");
        }

        cpu.PC = (hi << 8) | lo; // リセットベクタからPCを設定
        cpu.PB = 0x00; // プログラムバンクは0から開始
        cpu.S = 0x1ff; // スタックポインタ初期化
        cpu.P = 0x34; // ステータスフラグ初期値
        cpu.emulation = true; // 6502互換モードで開始
      }

      document.getElementById("rom").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        romData = new Uint8Array(await file.arrayBuffer());
        document.getElementById(
          "status"
        ).textContent;
        document.getElementById("start").disabled = false;
      });

      function run(cpu, bus, cycles = 1000) {
        for (let i = 0; i < cycles; i++) {
          cpu.step(bus);
        }
      }
      // ADD globally
const keys = {};
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);


      document.getElementById("start").addEventListener("click", () => {
        const canvas = document.getElementById("screen");

        const cpu = new CPU65C816();
        const ctx = canvas.getContext("2d");
        const ppu = new PPU(ctx);
        const bus = new Bus(romData, ppu);
        resetCPU(cpu, romData, "LoROM");
        ppu.reset();
        // ADD before frame()
bus.joypad1 =
  (keys.ArrowRight ? 1 << 0 : 0) |
  (keys.ArrowLeft  ? 1 << 1 : 0) |
  (keys.ArrowDown  ? 1 << 2 : 0) |
  (keys.ArrowUp    ? 1 << 3 : 0) |
  (keys.KeyZ       ? 1 << 4 : 0) |
  (keys.KeyX       ? 1 << 5 : 0) |
  (keys.Enter      ? 1 << 7 : 0);

        function frame() {
          // MODIFY frame()
for (let i = 0; i < 20000; i++) cpu.step(bus);
ppu.startVBlank(bus);
// MODIFY frame()

ppu.renderSprites();

document.getElementById("addr").textContent="0x"+cpu.PC.toString(16);
          // CPUがCGRAMに色を書き込む（青色）

          // 背景色を描画
          ppu.renderBGColor();
          ppu.renderBG1(); // 後で本物の描画に置き換える
          //updateDebug(cpu);
          requestAnimationFrame(frame);
        }

        frame();
      });
    </script>
  </body>
</html>